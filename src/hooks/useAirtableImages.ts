import { useState, useEffect, useCallback } from 'react';
import { initializeAirtable, getAirtableInstance, getProductBySku, getAllProductsWithImages } from '@/lib/airtable';

interface AirtableImageConfig {
  apiKey: string;
  baseId: string;
  productsTable: string;
  brandsTable?: string;
  imageField?: string;
  skuField?: string;
  nameField?: string;
}

interface ProductImage {
  recordId: string;
  sku: string;
  name: string;
  imageUrls: string[];
  lastUpdated?: Date;
}

interface BrandImage {
  recordId: string;
  name: string;
  imageUrls: string[];
  lastUpdated?: Date;
}

interface UseAirtableImagesReturn {
  // State
  productImages: Map<string, ProductImage>;
  brandImages: Map<string, BrandImage>;
  loading: boolean;
  error: string | null;
  
  // Functions
  initialize: (config: AirtableImageConfig) => Promise<void>;
  getProductImage: (sku: string) => ProductImage | null;
  getBrandImage: (brandName: string) => BrandImage | null;
  refreshImages: () => Promise<void>;
  fetchProductImage: (sku: string) => Promise<ProductImage | null>;
  fetchAllProductImages: () => Promise<void>;
  fetchAllBrandImages: () => Promise<void>;
  clearError: () => void;
  validateImageUrl: (url: string) => Promise<boolean>;
}

export const useAirtableImages = (): UseAirtableImagesReturn => {
  const [productImages, setProductImages] = useState<Map<string, ProductImage>>(new Map());
  const [brandImages, setBrandImages] = useState<Map<string, BrandImage>>(new Map());
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [config, setConfig] = useState<AirtableImageConfig | null>(null);

  // Clear error
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Validate image URL - simplified to avoid CORS issues
  const validateImageUrl = useCallback(async (url: string): Promise<boolean> => {
    // For Airtable URLs, we'll assume they're valid since they're generated by Airtable
    // CORS restrictions make it difficult to validate them properly
    if (url.includes('airtableusercontent.com')) {
      return true;
    }
    
    try {
      const response = await fetch(url, { 
        method: 'HEAD',
        mode: 'no-cors'
      });
      return true;
    } catch (err) {
      console.warn(`Image URL validation failed for: ${url}`, err);
      return false;
    }
  }, []);

  // Initialize Airtable with configuration
  const initialize = useCallback(async (airtableConfig: AirtableImageConfig) => {
    try {
      setLoading(true);
      setError(null);
      
      // Initialize Airtable API
      initializeAirtable({
        apiKey: airtableConfig.apiKey,
        baseId: airtableConfig.baseId,
        tableName: airtableConfig.productsTable,
      });
      
      setConfig(airtableConfig);
      
      console.log('‚úÖ Airtable initialized successfully');
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to initialize Airtable';
      setError(errorMessage);
      console.error('‚ùå Airtable initialization failed:', errorMessage);
      throw err; // Re-throw to allow caller to handle
    } finally {
      setLoading(false);
    }
  }, []);

  // Fetch image for a specific product by SKU with retry logic
  const fetchProductImage = useCallback(async (sku: string, retries: number = 2): Promise<ProductImage | null> => {
    if (!config) {
      console.warn('Airtable not initialized');
      return null;
    }

    for (let attempt = 0; attempt <= retries; attempt++) {
      try {
        const airtable = getAirtableInstance();
        const record = await getProductBySku(
          config.productsTable, 
          sku, 
          config.skuField || 'SKU'
        );

        if (!record) {
          console.log(`No Airtable record found for SKU: ${sku}`);
          return null;
        }

        const imageField = config.imageField || 'Images';
        const nameField = config.nameField || 'Name';
        
        const attachments = record.fields[imageField];
        const imageUrls = Array.isArray(attachments) 
          ? attachments.map((attachment: any) => attachment.url)
          : attachments ? [attachments.url] : [];

        // Use all image URLs without validation to avoid CORS issues
        const validImageUrls = imageUrls;

        const productImage: ProductImage = {
          recordId: record.id,
          sku: record.fields[config.skuField || 'SKU'],
          name: record.fields[nameField] || record.fields[config.skuField || 'SKU'], // Use SKU as name if name is not available
          imageUrls: validImageUrls,
          lastUpdated: new Date(),
        };

        // Update the cache
        setProductImages(prev => new Map(prev).set(sku, productImage));
        
        console.log(`‚úÖ Fetched Airtable image for SKU: ${sku} (${validImageUrls.length} valid images)`, productImage);
        return productImage;
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to fetch product image';
        console.error(`‚ùå Failed to fetch Airtable image for SKU ${sku} (attempt ${attempt + 1}/${retries + 1}):`, errorMessage);
        
        if (attempt === retries) {
          // Last attempt failed
          return null;
        }
        
        // Wait before retrying
        await new Promise(resolve => setTimeout(resolve, 1000 * (attempt + 1)));
      }
    }
    
    return null;
  }, [config, validateImageUrl]);

  // Fetch all product images with better error handling
  const fetchAllProductImages = useCallback(async () => {
    if (!config) {
      console.warn('Airtable not initialized');
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const products = await getAllProductsWithImages(config.productsTable, {
        imageField: config.imageField || 'Images',
        skuField: config.skuField || 'SKU',
        nameField: config.nameField || config.skuField, // Use SKU field if no name field is provided
        maxRecords: 1000, // Adjust based on your needs
        validateImages: false, // Disable image validation to avoid CORS issues
      });

      const newProductImages = new Map<string, ProductImage>();
      let validImagesCount = 0;
      let totalImagesCount = 0;

      for (const product of products) {
        // Map by SKU for easy lookup
        const productImage: ProductImage = {
          ...product,
          lastUpdated: new Date(),
        };
        
        newProductImages.set(product.sku, productImage);
        validImagesCount += product.imageUrls.length;
        totalImagesCount += product.imageUrls.length;
        
        console.log(`üì¶ Mapped SKU ${product.sku} with ${product.imageUrls.length} images`);
      }

      setProductImages(newProductImages);
      console.log(`‚úÖ Fetched ${products.length} product images from Airtable (${validImagesCount}/${totalImagesCount} valid images)`);
      console.log(`üîç Sample stored images:`, Array.from(newProductImages.entries()).slice(0, 3));
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch product images';
      setError(errorMessage);
      console.error('‚ùå Failed to fetch product images from Airtable:', errorMessage);
      throw err; // Re-throw to allow caller to handle
    } finally {
      setLoading(false);
    }
  }, [config]);

  // Fetch all brand images
  const fetchAllBrandImages = useCallback(async () => {
    if (!config?.brandsTable) {
      console.warn('Brands table not configured');
      return;
    }

    try {
      setLoading(true);
      setError(null);

      const airtable = getAirtableInstance();
      const records = await airtable.fetchRecords(config.brandsTable, {
        fields: ['Name', 'Logo'],
        maxRecords: 100,
      });

      const newBrandImages = new Map<string, BrandImage>();
      records.forEach(record => {
        const name = record.fields['Name'];
        const logo = record.fields['Logo'];
        
        if (name && logo) {
          const imageUrls = Array.isArray(logo) 
            ? logo.map((attachment: any) => attachment.url)
            : [logo.url];

          newBrandImages.set(name, {
            recordId: record.id,
            name,
            imageUrls,
            lastUpdated: new Date(),
          });
        }
      });

      setBrandImages(newBrandImages);
      console.log(`‚úÖ Fetched ${newBrandImages.size} brand images from Airtable`);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to fetch brand images';
      setError(errorMessage);
      console.error('‚ùå Failed to fetch brand images from Airtable:', errorMessage);
      throw err; // Re-throw to allow caller to handle
    } finally {
      setLoading(false);
    }
  }, [config]);

  // Get product image from cache
  const getProductImage = useCallback((sku: string): ProductImage | null => {
    return productImages.get(sku) || null;
  }, [productImages]);

  // Get brand image from cache
  const getBrandImage = useCallback((brandName: string): BrandImage | null => {
    return brandImages.get(brandName) || null;
  }, [brandImages]);

  // Refresh all images
  const refreshImages = useCallback(async () => {
    if (!config) {
      console.warn('Airtable not initialized');
      return;
    }

    try {
      setLoading(true);
      setError(null);

      // Fetch only SKU images (brand images disabled)
      await fetchAllProductImages();

      console.log('‚úÖ Refreshed SKU images from Airtable');
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to refresh images';
      setError(errorMessage);
      console.error('‚ùå Failed to refresh Airtable images:', errorMessage);
      throw err; // Re-throw to allow caller to handle
    } finally {
      setLoading(false);
    }
  }, [config, fetchAllProductImages]);

  // Auto-refresh images when config changes - disabled to prevent clearing images
  // useEffect(() => {
  //   if (config) {
  //     refreshImages().catch(err => {
  //       console.error('Auto-refresh failed:', err);
  //     });
  //   }
  // }, [config, refreshImages]);

  return {
    // State
    productImages,
    brandImages,
    loading,
    error,
    
    // Functions
    initialize,
    getProductImage,
    getBrandImage,
    refreshImages,
    fetchProductImage,
    fetchAllProductImages,
    fetchAllBrandImages,
    clearError,
    validateImageUrl,
  };
};
