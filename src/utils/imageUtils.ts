/**
 * Image utility functions for product image handling
 */

export interface ImageValidationResult {
  isValid: boolean;
  error?: string;
  statusCode?: number;
}

/**
 * Validate if an image URL is accessible
 */
export const validateImageUrl = async (url: string): Promise<ImageValidationResult> => {
  if (!url) {
    return { isValid: false, error: 'URL is empty' };
  }

  try {
    // For Airtable URLs, we'll assume they're valid since they're generated by Airtable
    if (url.includes('airtableusercontent.com')) {
      return { isValid: true };
    }

    const response = await fetch(url, { 
      method: 'HEAD',
      mode: 'no-cors' // Try to avoid CORS issues
    });
    
    return { isValid: true };
  } catch (error) {
    return { 
      isValid: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
};

/**
 * Get the best available image URL from multiple sources
 */
export const getBestImageUrl = (
  airtableImageUrl?: string,
  databaseImageUrl?: string,
  fallbackUrl?: string
): string | undefined => {
  return airtableImageUrl || databaseImageUrl || fallbackUrl;
};

/**
 * Extract image URLs from Airtable attachment field
 */
export const extractAirtableImageUrls = (attachments: any): string[] => {
  if (!attachments) return [];
  
  if (Array.isArray(attachments)) {
    return attachments
      .filter((attachment: any) => attachment && attachment.url)
      .map((attachment: any) => attachment.url);
  }
  
  if (attachments.url) {
    return [attachments.url];
  }
  
  return [];
};

/**
 * Create a fallback display for missing images
 */
export const createImageFallback = (
  productName: string,
  size: 'sm' | 'md' | 'lg' | 'xl' = 'md'
): { initial: string; text: string } => {
  const initial = productName.charAt(0).toUpperCase();
  const text = size === 'lg' || size === 'xl' ? 'No Image' : '';
  
  return { initial, text };
};

/**
 * Check if an image URL is from Airtable
 */
export const isAirtableImageUrl = (url: string): boolean => {
  return url.includes('airtableusercontent.com');
};

/**
 * Check if an image URL is from Supabase storage
 */
export const isSupabaseImageUrl = (url: string): boolean => {
  return url.includes('supabase.co') || url.includes('supabase.com');
};

/**
 * Get image source type
 */
export const getImageSourceType = (url: string): 'airtable' | 'supabase' | 'external' => {
  if (isAirtableImageUrl(url)) return 'airtable';
  if (isSupabaseImageUrl(url)) return 'supabase';
  return 'external';
};

/**
 * Format image size for display
 */
export const formatImageSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
};

/**
 * Generate a unique image key for caching
 */
export const generateImageKey = (sku: string, imageUrl: string): string => {
  return `${sku}_${btoa(imageUrl).slice(0, 16)}`;
};

/**
 * Debounce function for image loading
 */
export const debounce = <T extends (...args: any[]) => any>(
  func: T,
  wait: number
): ((...args: Parameters<T>) => void) => {
  let timeout: NodeJS.Timeout;
  
  return (...args: Parameters<T>) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => func(...args), wait);
  };
};

/**
 * Preload an image
 */
export const preloadImage = (url: string): Promise<HTMLImageElement> => {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
};

/**
 * Batch preload images
 */
export const preloadImages = async (urls: string[]): Promise<HTMLImageElement[]> => {
  const promises = urls.map(url => preloadImage(url));
  return Promise.allSettled(promises)
    .then(results => 
      results
        .filter((result): result is PromiseFulfilledResult<HTMLImageElement> => 
          result.status === 'fulfilled'
        )
        .map(result => result.value)
    );
};
